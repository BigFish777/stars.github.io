[{"title":"深入浅出Java虚拟机篇-运行时的数据区域","date":"2021-05-29T14:18:08.000Z","url":"/stars.github.io/2021/05/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/","tags":[["JAVA","/stars.github.io/tags/JAVA/"]],"categories":[["undefined",""]],"content":" 文章大容来自《深入理解Java虚拟机》一、运行时数据区域(JVM内存模型) ​ 在Java虚拟机中执行Java程序的过程都会把他所管理的内存划分为若干个不同的数据区域。这些区域各有各自的用途，有的区域随着虚拟机的进程的启动而一直存在，有的区域则是随着用户线程的启动而启动，结束而销毁。这些区域根据《Java虚拟机规范》的规定共同组成了运行时区域。也就是JVM的内存模型的组成。 1.1 程序计数器（Program Counter Register）1.1.1 程序计数器是什么？🧐又能干什么？​ 程序计数器简单的理解，他是当前线程所执行的字节码行号指示器。通过它可以知道下一条要执行字节码指令。他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等都需要依赖它来完成。 ​ 注意：由于Java虚拟机中的多线程是通过线程轮流切换来分配处理器执行时间的，也就是在任何一个时刻，处理器都只会处理一条线程中的指令，并且的话处理器不敢保证每个线程的程序都会执行完成，也就是说当线程一执行一半切换到线程二时，如果没有程序计数器记录当前线程中指令执行的位置，那就会导致每次线程再次被处理器执行时，就会从头再来。因此，为了线程切换后能恢复到正确的执行位置每条线程都需要一个自己独有的程序计数器，各个线程之间的程序计数器互不影响，独立储存。所以我们称这一类的内存区域为”线程私有“. 1.2 JAVA虚拟机栈（Java Virtual Machine Stack）​ java虚拟机栈是线程私有的，他的生命周期与线程相同。虚拟机栈是Java方法执行的线程内存模型：每个方法被执行时，都会同步创建一个栈帧（Stack Frame）用于储存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的调用到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 1.2.1 局部变量表​ 局部变量表存放了编译期何种Java虚拟机基本数据类型、对象引用（引用指针、句柄或者于此对象相关的位置）和returnAddress。 ​ 这些数据在局部变量表中都以局部变量槽（Slot）来表示，其中64位的长度的long和double类型的数据会占两个变量槽，其余的只会占一个。 1.2.2 异常在《Java虚拟机规范中》中，虚拟机栈规定了两类的异常状况： StackOverflowError：当线程请求的栈深度大于了虚拟机所允许的栈深度就会抛出该异常 StackOverflowError（堆栈溢出错误） demo: 在上面的案例中我们可以看出他是一段简单的递归调用，但是并没有指定结束条件。就导致了成了一个死循环，这时我们在下图中可以看出来，他会不断的进行入栈，直到栈深度大于了虚拟机限制的深度，抛出了 java.lang.StackOverflowError OutOfMemoryError: 当栈扩展时无法申请到足够的内存时就会抛出OutOfMemoryError。但是在HotSpot 中虚拟机栈容量是不可以的动态扩展的，也就是不会出现OOM, 但其实不然，如果申请时就失败，仍然会出现OOM异常。 1.3 本地方法栈（Native Method Stack）本地方法栈与虚拟机栈类似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈是为了虚拟机栈使用的。 1.4 Java 堆（Heap）​ Java堆是线程共享的内存区域，在虚拟机创建时创建，此内存区域的唯一目的就是存放实例对象，在《JAVA虚拟机规范》中队java 堆描述是：”The heap is the runtime data area from which memory for all class instances and arrays is allocated（所有的Java对象实例以及数组在堆上分配）“。这个几乎就很有深度。随着Java语言的发展，现在可以看到未来可能会出现值类型的支持，由于即时编译的技术进步，像逃逸分析、栈上分配、标量替换优化手段，Java对象实例分配在堆已经不在呢么绝对了。 Java是垃圾回收管理的内存区域，因此也称作”GC堆”，现在垃圾收集器大部分都是基于分代收集理论设计的，因此经常会出现 ”新生代“、”老年代“、”Eden 空间“、”From Survivor 空间“、”To Survivor 空间“等名词。 在十几年前， HotSpot虚拟机内部的垃圾回收内存器是全部 经典分代来设计的：新生代、老年代收集器搭配工作。在这种背景下这些说发还是能不会产生太多的歧义的。但是到了如今的今天，垃圾收集器技术与十几年前早已不同，HotSpot里面也出现了非分代设计的垃圾收集器。 下图为分代设计的垃圾收集器内存模型： 1.3.2 异常​ 当Java堆中没有内存完成实力分配，并且无法扩展时，Java虚拟机就会抛出 OutOfMemoryError异常。 demo: [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BdFPQuzF-1622222314288)(C:\\Users\\24267\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210529002804273.png)] 1.5 方法区（Method Area）​ 方法区和堆一样，是线程共享的内存区域，它用来储存虚拟机加载的类信息、常量、静态变量以及即时编译后的代码缓存数据。他还有一个别称叫做 非堆 ，目的就是为了区分java堆。 ​ 方法区在JDK8之前，许多人都叫做永久代。，其实本质上本质上两者并不是等价的，因为仅仅是当时的HosSpot虚拟机设计团队选择吧垃圾收集器的分代设计至方法区，或者说使用永久代来实现方法区而已，使得HotSpot虚拟机的垃圾回收器能够像管理Java堆一样管理者部分的内存，省的专门为方法区编写内存管理代码的工作。这部分内存的区域的回收主要针对常量池的回收和对类型的卸载。 1.6 运行时常量池（Runtime Constant Poll）​ 运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Poll Ttable）, 用于存放编译期间生成的各种字面量与符号引用，这部分内用将在类加载后存档到方法区的运行时常量池中。"},{"title":"mybatis源码分析--mybatis配置阶段的执行流程分析","date":"2021-05-27T10:33:18.499Z","url":"/stars.github.io/2021/05/27/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-mybatis%E9%85%8D%E7%BD%AE%E9%98%B6%E6%AE%B5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/","categories":[["undefined",""]],"content":"mybatis源码分析-mybatis配置阶段的执行流程分析看源码到底怎么去看，我总结的是要有目的的去看源码。例如mybatis,我们在github拉下来源码后发现一堆代码，没头没尾无从下手。但是如果我们先写一个Demo,来分析这个demo的每一步到底干了什么，就好分析了。这也就是为啥学习一门新技术都需要先学习怎么使用。 创建一个maven项目，引入mybatis的依赖 项目目录结构 创建一个实体类和对应的mapper接口 mapper.xml一段很简单的sql语句，就是查询全部的file文件，我已经提前在数据库中插入了几条数据。数据库就不展示了，很简单就这几个字段。 在resource文件夹下创建一个myabtis-config.xml全局配置文件 现在创建main方法继续测试 源码分析阶段这段代码中核心的代码只有四句代码，这四句我把整个mybatis 从配置到执行sql语句得到想要的结果 分为两个阶段： 配置阶段 执行阶段 我们一个一个的分析每个阶段的源码，首先是配置阶段,这个阶段我们首先要提出问题。 SqlSessionFactory得到build需要将xml配置文件，他拿到这配置文件做了什么？怎么做的？ 我们点击 build(reader,properties) 方法里面看一看他到底做了什么，点击去我们发现他最终调用了这个build方法,在这个方法里面创建了一个XMLConfigBuilder对象 解析配置文件的关键逻辑都委托给XMLConfigBuilder，我们进入这个类一探究竟。这个类中最重要的三个方法都在这里 我们发现在parseConfiguration（）方法中对xml配置文件进行了解析，此方法就是解析configuration节点下的子节点，解析的顺序是按照配置文件的配置顺序依次进行的解析。其中最重要得到的解析，这里就是对mapper的解析处理，我们进去方法mapperElement看一看是怎么实现的。 这段代码长一点，我们把它分一下类,从代码上我们可以看出，他按照child.getName()的不同分别进行了处理 一共四种情况，也就是mybatis.xml配置文件四种不同标签加载mapper的方法。虽然分为了四种情况但是他最终执行的代码是相同的，我们只看package包扫描的方式，因为这种方式用的比较多。 我们看一下包扫描这种方法到底干了什么？ 点击这个方法 configuration.addMappers(“mapper接口的包名”)，我就康康不乱动！(●ˇ∀ˇ●) 点击config的addMappers方法发现又是老样子，他又交给了别人处理了 config是调用了mapperRegistry的addMappers方法，好吧！我进入的深一点，我再跟进去。 当我进入这个方法的时候发现，哎,这里的代码多肯定是这里没错了。我们看看这里做了什么操作。 首先得到了一个包搜索工具 resolverUtil 通过这个工具拿到了这个包下所有的mapper接口的class对象mapperSet，是一个set集合，然后遍历集合，他又调用了 addMappers方法，这次传递的参数是每个mapper接口的class对象。没办法再进去看看 这片代码写了啥，一堆的判断….. 嗯就一两句我们想看到的 第一个 让我们终于知道了，我们那些mapper接口到底去哪里了，原来在这个他为每个mapper接口创建了一一对应的MapperProxyFactory代理工厂，并将这些工厂存放到了 map对象中。 key: mapperClass value：MapperProxyFactory&lt;&gt;(mapperClass) 第二个 用于解析我们定义的XxxMapper接口里面使用的注解，这主要是处理不使用xml映射文件的情况。这里不在深入，谁想看自己去看。 最后还执行了一句解析 parser.parse()，这个解析到底在解析什么，我们在~~~~点击去看一下。 这里东西有点多，看一下的我的源码片段，这里我都进行了注释。 loadXmlResource这个方法将mapper.xml进行了解析，具体怎么解析自己看。 到现在我们知道了mybatis配置阶段到底执行了那东西。 接下来就是sql执行阶段了，欲知后事如何，且听下次讲解"},{"title":"Hello World","date":"2021-05-19T08:02:58.892Z","url":"/stars.github.io/2021/05/19/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]