<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一颗小土豆</title>
  
  <subtitle>一颗小土豆</subtitle>
  <link href="https://bigfish777.github.io/stars.github.io/atom.xml" rel="self"/>
  
  <link href="https://bigfish777.github.io/stars.github.io/"/>
  <updated>2021-05-30T14:30:56.509Z</updated>
  <id>https://bigfish777.github.io/stars.github.io/</id>
  
  <author>
    <name>一颗小土豆</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入浅出Java虚拟机篇-运行时的数据区域</title>
    <link href="https://bigfish777.github.io/stars.github.io/2021/05/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
    <id>https://bigfish777.github.io/stars.github.io/2021/05/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AF%87-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</id>
    <published>2021-05-29T14:18:08.000Z</published>
    <updated>2021-05-30T14:30:56.509Z</updated>
    
    <content type="html"><![CDATA[<ul><li>文章大容来自《深入理解Java虚拟机》<h2 id="一、运行时数据区域-JVM内存模型"><a href="#一、运行时数据区域-JVM内存模型" class="headerlink" title="一、运行时数据区域(JVM内存模型)"></a>一、运行时数据区域(JVM内存模型)</h2></li></ul><p>​    在Java虚拟机中执行Java程序的过程都会把他所管理的内存划分为若干个不同的数据区域。这些区域各有各自的用途，有的区域随着虚拟机的进程的启动而一直存在，有的区域则是随着用户线程的启动而启动，结束而销毁。这些区域根据《Java虚拟机规范》的规定共同组成了运行时区域。也就是JVM的内存模型的组成。</p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGQzYjE1YjNkODgyNmZhZWFlMjA2Mzk3NmZiOTkyMTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img" style="zoom: 67%;" /><h3 id="1-1-程序计数器（Program-Counter-Register）"><a href="#1-1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.1 程序计数器（Program Counter Register）"></a>1.1 程序计数器（Program Counter Register）</h3><h5 id="1-1-1-程序计数器是什么？🧐又能干什么？"><a href="#1-1-1-程序计数器是什么？🧐又能干什么？" class="headerlink" title="1.1.1 程序计数器是什么？🧐又能干什么？"></a>1.1.1 程序计数器是什么？🧐又能干什么？</h5><p>​    <strong>程序计数器简单的理解，他是当前线程所执行的字节码行号指示器。通过它可以知道下一条要执行字节码指令。</strong>他是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等都需要依赖它来完成。</p><p>​    <strong>注意：</strong>由于Java虚拟机中的多线程是通过线程轮流切换来分配处理器执行时间的，也就是在任何一个时刻，处理器都只会处理一条线程中的指令，并且的话处理器不敢保证每个线程的程序都会执行完成，也就是说当线程一执行一半切换到线程二时，如果没有程序计数器记录当前线程中指令执行的位置，那就会导致每次线程再次被处理器执行时，就会从头再来。<strong>因此，为了线程切换后能恢复到正确的执行位置每条线程都需要一个自己独有的程序计数器，各个线程之间的程序计数器互不影响，独立储存。所以我们称这一类的内存区域为”<code>线程私有</code>“.</strong></p><h3 id="1-2-JAVA虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#1-2-JAVA虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="1.2 JAVA虚拟机栈（Java Virtual Machine Stack）"></a>1.2 JAVA虚拟机栈（Java Virtual Machine Stack）</h3><p>​    java虚拟机栈是<strong>线程私有的</strong>，他的生命周期与线程相同。虚拟机栈是Java方法执行的线程内存模型：每个方法被执行时，都会同步创建一个<strong>栈帧</strong>（Stack Frame）用于储存<code>局部变量表</code>、<code>操作数栈</code>、<code>动态链接</code>、<code>方法出口</code>等信息。每个方法的调用到执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h5 id="1-2-1-局部变量表"><a href="#1-2-1-局部变量表" class="headerlink" title="1.2.1 局部变量表"></a>1.2.1 局部变量表</h5><p>​    局部变量表存放了编译期何种Java虚拟机基本数据类型、对象引用（引用指针、句柄或者于此对象相关的位置）和returnAddress。</p><p>​    这些数据在局部变量表中都以<strong>局部变量槽（Slot）</strong>来表示，其中64位的长度的long和double类型的数据会占两个变量槽，其余的只会占一个。</p><h5 id="1-2-2-异常"><a href="#1-2-2-异常" class="headerlink" title="1.2.2 异常"></a>1.2.2 异常</h5><p>在《Java<strong>虚拟机规范中</strong>》中，虚拟机栈规定了两类的异常状况：</p><p><strong>StackOverflowError：</strong>当线程请求的栈深度大于了虚拟机所允许的栈深度就会抛出该异常 StackOverflowError（堆栈溢出错误）</p><p><strong>demo:</strong> </p><pre><code class="java">    private static int stackLength;    public static void stackLeak()&#123;        stackLength++;        stackLeak();    &#125;    /**     * 最大堆大小: -Xmx5M     */    public static void main(String[] args) &#123;        try &#123;            stackLeak();        &#125;catch (Throwable e)&#123;            e.printStackTrace();            System.out.println(&quot;stack length: &quot;+ stackLength);        &#125;    &#125;    // 虚拟机栈深度为：23812  抛出StackOverFlowError异常    // Exception in thread &quot;main&quot; java.lang.StackOverflowError    // stack length: 23812</code></pre><p>在上面的案例中我们可以看出他是一段简单的递归调用，但是并没有指定结束条件。就导致了成了一个死循环，这时我们在下图中可以看出来，他会不断的进行入栈，直到栈深度大于了虚拟机限制的深度，抛出了 <code>java.lang.StackOverflowError</code></p><p><img src="https://img-blog.csdnimg.cn/20210529011945511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2NDM5OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>OutOfMemoryError:</strong> 当栈扩展时无法申请到足够的内存时就会抛出OutOfMemoryError。但是在HotSpot 中虚拟机栈容量是不可以的动态扩展的，也就是不会出现<code>OOM</code>, 但其实不然，如果申请时就失败，仍然会出现<code>OOM</code>异常。</p><h3 id="1-3-本地方法栈（Native-Method-Stack）"><a href="#1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.3 本地方法栈（Native Method Stack）"></a>1.3 本地方法栈（Native Method Stack）</h3><p>本地方法栈与虚拟机栈类似，区别是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈是为了虚拟机栈使用的。</p><h3 id="1-4-Java-堆（Heap）"><a href="#1-4-Java-堆（Heap）" class="headerlink" title="1.4 Java 堆（Heap）"></a>1.4 Java 堆（Heap）</h3><p>​    Java堆是线程共享的内存区域，在虚拟机创建时创建，此内存区域的唯一目的就是存放实例对象，在《JAVA虚拟机规范》中队java 堆描述是：”The heap is the runtime data area from which memory for all class instances and arrays is allocated（所有的Java对象实例以及数组在堆上分配）“。这个<code>几乎</code>就很有深度。随着Java语言的发展，现在可以看到未来可能会出现值类型的支持，由于即时编译的技术进步，像逃逸分析、栈上分配、标量替换优化手段，Java对象实例分配在堆已经不在呢么绝对了。</p><p>Java是垃圾回收管理的内存区域，因此也称作”GC堆”，现在垃圾收集器大部分都是基于分代收集理论设计的，因此经常会出现 ”新生代“、”老年代“、”Eden 空间“、”From Survivor 空间“、”To Survivor 空间“等名词。 在十几年前， HotSpot虚拟机内部的垃圾回收内存器是全部 <code>经典分代</code>来设计的：新生代、老年代收集器搭配工作。在这种背景下这些说发还是能不会产生太多的歧义的。但是到了如今的今天，垃圾收集器技术与十几年前早已不同，HotSpot里面也出现了非分代设计的垃圾收集器。</p><p>下图为分代设计的垃圾收集器内存模型：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" alt="img"></p><h5 id="1-3-2-异常"><a href="#1-3-2-异常" class="headerlink" title="1.3.2 异常"></a>1.3.2 异常</h5><p>​    当Java堆中没有内存完成实力分配，并且无法扩展时，Java虚拟机就会抛出 <code>OutOfMemoryError</code>异常。 </p><p><strong>demo:</strong></p><pre><code class="java">/**   * -Xmx2M  * Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space  *     at com.xphu.DemoTest.main(DemoTest.java:5)  */public static void main(String[] args) &#123;    byte[] bytes = new byte[1024 * 1024 * 1024];    System.out.println(bytes.length);&#125;    </code></pre><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BdFPQuzF-1622222314288)(C:\Users\24267\AppData\Roaming\Typora\typora-user-images\image-20210529002804273.png)]</p><h3 id="1-5-方法区（Method-Area）"><a href="#1-5-方法区（Method-Area）" class="headerlink" title="1.5 方法区（Method Area）"></a>1.5 方法区（Method Area）</h3><p>​    方法区和堆一样，是线程共享的内存区域，它用来储存虚拟机加载的类信息、常量、静态变量以及即时编译后的代码缓存数据。他还有一个别称叫做 <code>非堆</code> ，目的就是为了区分java堆。</p><p>​    方法区在JDK8之前，许多人都叫做永久代。，其实本质上本质上两者并不是等价的，因为仅仅是当时的HosSpot虚拟机设计团队选择吧垃圾收集器的分代设计至方法区，或者说使用永久代来实现方法区而已，使得HotSpot虚拟机的垃圾回收器能够像管理Java堆一样管理者部分的内存，省的专门为方法区编写内存管理代码的工作。这部分内存的区域的回收主要针对常量池的回收和对类型的卸载。</p><h3 id="1-6-运行时常量池（Runtime-Constant-Poll）"><a href="#1-6-运行时常量池（Runtime-Constant-Poll）" class="headerlink" title="1.6 运行时常量池（Runtime Constant Poll）"></a>1.6 运行时常量池（Runtime Constant Poll）</h3><p>​    运行时常量池时方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息时常量池表（Constant Poll Ttable）, 用于存放编译期间生成的各种字面量与符号引用，这部分内用将在类加载后存档到方法区的运行时常量池中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;文章大容来自《深入理解Java虚拟机》&lt;h2 id=&quot;一、运行时数据区域-JVM内存模型&quot;&gt;&lt;a href=&quot;#一、运行时数据区域-JVM内存模型&quot; class=&quot;headerlink&quot; title=&quot;一、运行时数据区域(JVM内存模型)&quot;&gt;&lt;/a&gt;一、运行时数</summary>
      
    
    
    
    
    <category term="JAVA" scheme="https://bigfish777.github.io/stars.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>mybatis源码分析--mybatis配置阶段的执行流程分析</title>
    <link href="https://bigfish777.github.io/stars.github.io/2021/05/27/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-mybatis%E9%85%8D%E7%BD%AE%E9%98%B6%E6%AE%B5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://bigfish777.github.io/stars.github.io/2021/05/27/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-mybatis%E9%85%8D%E7%BD%AE%E9%98%B6%E6%AE%B5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-05-27T10:33:18.499Z</published>
    <updated>2021-05-27T10:33:18.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mybatis源码分析-mybatis配置阶段的执行流程分析"><a href="#mybatis源码分析-mybatis配置阶段的执行流程分析" class="headerlink" title="mybatis源码分析-mybatis配置阶段的执行流程分析"></a>mybatis源码分析-mybatis配置阶段的执行流程分析</h2><p>看源码到底怎么去看，我总结的是要有目的的去看源码。例如mybatis,我们在github拉下来源码后发现一堆代码，没头没尾无从下手。<br>但是如果我们先写一个Demo,来分析这个demo的每一步到底干了什么，就好分析了。<br>这也就是为啥学习一门新技术都需要先学习怎么使用。</p><h5 id="创建一个maven项目，引入mybatis的依赖"><a href="#创建一个maven项目，引入mybatis的依赖" class="headerlink" title="创建一个maven项目，引入mybatis的依赖"></a>创建一个maven项目，引入mybatis的依赖</h5><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h5><p><img src="C:\Users\24267\AppData\Roaming\Typora\typora-user-images\image-20210311132924065.png" alt="image-20210311132924065"></p><h5 id="创建一个实体类和对应的mapper接口"><a href="#创建一个实体类和对应的mapper接口" class="headerlink" title="创建一个实体类和对应的mapper接口"></a>创建一个实体类和对应的mapper接口</h5><pre><code class="java">/** 实体类 */public class File &#123;    private Integer id;    private Integer parentId;    private String name;    private Integer isFolder;    .... 省略get/set&#125;/** mapper接口 */public interface FileMapper &#123;    List&lt;File&gt; selectList();&#125;</code></pre><h5 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h5><p>一段很简单的sql语句，就是查询全部的file文件，我已经提前在数据库中插入了几条数据。数据库就不展示了，很简单就这几个字段。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.internal.example.mapper.FileMapper&quot;&gt;    &lt;select id=&quot;selectList&quot; resultType=&quot;org.mybatis.internal.example.pojo.File&quot;&gt;        select id,parent_id parentId, name, is_folder isFolder from file;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h5 id="在resource文件夹下创建一个myabtis-config-xml全局配置文件"><a href="#在resource文件夹下创建一个myabtis-config-xml全局配置文件" class="headerlink" title="在resource文件夹下创建一个myabtis-config.xml全局配置文件"></a>在resource文件夹下创建一个<code>myabtis-config.xml</code>全局配置文件</h5><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties&gt;        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;    &lt;!--    配置别名 可以在mapper.xml中 使用简称就可以不用使用群全名了--&gt;    &lt;typeAliases&gt;&lt;!--        指定类设置别名--&gt;&lt;!--        &lt;typeAlias alias=&quot;user&quot; type=&quot;org.mybatis.internal.example.pojo.User&quot;/&gt;--&gt;&lt;!--        &lt;typeAlias alias=&quot;str&quot; type=&quot;java.lang.String&quot;/&gt;--&gt;&lt;!--        包扫面式的添加类别名，默认为类名首字母变为小写 如果个别的类需要指定别名可以使用 @Alias(&quot;us&quot;) 添加在实体类上--&gt;        &lt;package name=&quot;org.mybatis.internal.example.pojo&quot;/&gt;    &lt;/typeAliases&gt;&lt;!--    多数据源--&gt;    &lt;environments default=&quot;development2&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--            数据源模式 POOLED                dataSource的类型可以配置成其内置类型之一，如UNPOOLED、POOLED、JNDI。            　　如果将类型设置成UNPOOLED，mybaties会为每一个数据库操作创建一个新的连接，并关闭它。            该方式适用于只有小规模数量并发用户的简单应用程序上。            　　如果将属性设置成POOLED，mybaties会创建一个数据库连接池，            连接池的一个连接将会被用作数据库操作。一旦数据库操作完成，mybaties会将此连接返回给连接池。            在开发或测试环境中经常用到此方式。            　　如果将类型设置成JNDI。mybaties会从在应用服务器向配置好的JNDI数据源DataSource获取数据库连接。            在生产环境中优先考虑这种方式。--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;        &lt;environment id=&quot;development2&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--            数据源模式 POOLED                dataSource的类型可以配置成其内置类型之一，如UNPOOLED、POOLED、JNDI。            　　如果将类型设置成UNPOOLED，mybaties会为每一个数据库操作创建一个新的连接，并关闭它。            该方式适用于只有小规模数量并发用户的简单应用程序上。            　　如果将属性设置成POOLED，mybaties会创建一个数据库连接池，连接池的一个连接将会被用作数据库操作。            一旦数据库操作完成，mybaties会将此连接返回给连接池。在开发或测试环境中经常用到此方式。            　　如果将类型设置成JNDI。mybaties会从在应用服务器向配置好的JNDI数据源DataSource获取数据库连接。            在生产环境中优先考虑这种方式。--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;        &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;        &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;        &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;    &lt;/databaseIdProvider&gt;&lt;!--    第一类是使用package自动搜索的模式，这样指定package下所有接口都会被注册为mapper，--&gt;&lt;!--    &lt;mappers&gt;--&gt;&lt;!--        &lt;mapper resource=&quot;mapper\UserMapper.xml&quot;/&gt;--&gt;&lt;!--        &lt;mapper resource=&quot;mapper\FileMapper.xml&quot;/&gt;--&gt;&lt;!--    &lt;/mappers&gt;--&gt;    &lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;    &lt;mappers&gt;        &lt;package name=&quot;org.mybatis.internal.example.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;!--   另外一类是明确指定mapper，这又可以通过resource、url或者class进行细分。例如：--&gt;&lt;!--    &lt;mappers&gt;--&gt;&lt;!--        &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;--&gt;&lt;!--        &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;--&gt;&lt;!--        &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;--&gt;&lt;!--    &lt;/mappers&gt;--&gt;&lt;/configuration&gt;</code></pre><h5 id="现在创建main方法继续测试"><a href="#现在创建main方法继续测试" class="headerlink" title="现在创建main方法继续测试"></a>现在创建main方法继续测试</h5><pre><code class="java">public class MybatisHelloWorld &#123;    // 配置阶段        // 得到mybatis 配置类的文件路径        String resource = &quot;mybatis/Configuration.xml&quot;;        Reader reader = null;        SqlSession session = null;        try&#123;            Yaml yml = new Yaml();            LinkedHashMap map = yml.loadAs(MybatisHelloWorld.class                                .getClassLoader()                                .getResourceAsStream(&quot;config.yml&quot;), LinkedHashMap.class);            System.out.println(map);            Map dataSourceMap = (Map)map.get(&quot;dataSource&quot;);            System.out.println(dataSourceMap.get(&quot;username&quot;));            // 通过Resources.getResourceAsReader 得到配置文件的字节流            reader = Resources.getResourceAsReader(resource);            // 这里的Properties 和配置文件Configuration.xml 里面的一致，使用Java配置可以实现动态的properties            Properties properties = new Properties();//            properties.setProperty(&quot;username&quot;, dataSourceMap.get(&quot;username&quot;) + &quot;&quot;);            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader,properties);            // 执行SQL阶段            // 得到一个session连接            session = sqlSessionFactory.openSession();            FileMapper fileMaper = session.getMapper(FileMapper.class);            List&lt;File&gt; fileList = fileMaper.selectList();            list.forEach(System.out::println);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            session.commit();            session.close();        &#125;       &#125;</code></pre><h3 id="源码分析阶段"><a href="#源码分析阶段" class="headerlink" title="源码分析阶段"></a>源码分析阶段</h3><p>这段代码中核心的代码只有四句代码，这四句我把整个mybatis 从配置到执行sql语句得到想要的结果 分为两个阶段：</p><ul><li> <code>配置阶段</code> </li><li><code>执行阶段</code></li></ul><pre><code class="java">// 配置阶段// 创建sqlsession工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader,properties);// 得到一个session连接session = sqlSessionFactory.openSession();// 执行阶段// 获得mapper代理类FileMapper fileMaper = session.getMapper(FileMapper.class);// 执行查询方法List&lt;File&gt; fileList = fileMaper.selectList();</code></pre><p>我们一个一个的分析每个阶段的源码，首先是<code>配置阶段</code>,这个阶段我们首先要提出问题。</p><ul><li>SqlSessionFactory得到build需要将xml配置文件，他拿到这配置文件做了什么？怎么做的？</li></ul><pre><code class="java">// 创建sqlsession工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader,properties);// 得到一个session连接session = sqlSessionFactory.openSession();</code></pre><p>我们点击 build(reader,properties) 方法里面看一看他到底做了什么，点击去我们发现他最终调用了这个build方法,在这个方法里面创建了一个XMLConfigBuilder对象</p><pre><code class="java">public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;    try &#123;//      解析配置文件的关键逻辑都委托给XMLConfigBuilder      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);      return build(parser.parse());    &#125; catch (Exception e) &#123;      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);    &#125; finally &#123;      ErrorContext.instance().reset();      try &#123;        reader.close();      &#125; catch (IOException e) &#123;        // Intentionally ignore. Prefer previous error.      &#125;    &#125;  &#125;</code></pre><p>解析配置文件的关键逻辑都委托给XMLConfigBuilder，我们进入这个类一探究竟。这个类中最重要的三个方法都在这里</p><pre><code class="java">  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;    super(new Configuration());    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);    this.configuration.setVariables(props);    this.parsed = false;    this.environment = environment;    this.parser = parser;  &#125;  /**   * 外部调用此方法对mybatis配置文件进行解析   * 第四步 真正Configuration构建逻辑就在XMLConfigBuilder.parse()里面   */  public Configuration parse() &#123;    if (parsed) &#123;      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);    &#125;    parsed = true;    //mybatis配置文件解析的主流程    //从根节点configuration    // 返回根节点 parser.evalNode(&quot;/configuration&quot;)    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));    return configuration;  &#125;  //此方法就是解析configuration节点下的子节点  //由此也可看出，我们在configuration下面能配置的节点为以下11个节点  private void parseConfiguration(XNode root) &#123;    try &#123;      // issue #117 read properties first      // 这里是按照官网的配置文件顺序进行解析的 https://mybatis.org/mybatis-3/zh/configuration.html      propertiesElement(root.evalNode(&quot;properties&quot;));      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));      loadCustomVfs(settings);      loadCustomLogImpl(settings);      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));      pluginElement(root.evalNode(&quot;plugins&quot;));      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));      settingsElement(settings);      // read it after objectFactory and objectWrapperFactory issue #631      environmentsElement(root.evalNode(&quot;environments&quot;));      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));      mapperElement(root.evalNode(&quot;mappers&quot;));    &#125; catch (Exception e) &#123;      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);    &#125;  &#125;</code></pre><p>我们发现在parseConfiguration（）方法中对xml配置文件进行了解析，此方法就是解析configuration节点下的子节点，解析的顺序是按照配置文件的配置顺序依次进行的解析。其中最重要得到<mappers>的解析，这里就是对mapper的解析处理，我们进去方法mapperElement看一看是怎么实现的。</p><pre><code class="java">/** *  加载mapper文件mapperElement * 　mapper文件是mybatis框架的核心之处，所有的用户sql语句都编写在mapper文件中，所以理解mapper文件对于所有的开发人员来说都是必备的要求 * @param parent * @throws Exception */private void mapperElement(XNode parent) throws Exception &#123;  if (parent != null) &#123;    for (XNode child : parent.getChildren()) &#123;      // 如果要同时使用package自动扫描和通过mapper明确指定要加载的mapper，一定要确保package自动扫描的范围不包含明确指定的mapper，      // 否则在通过package扫描的interface的时候，尝试加载对应xml文件的loadXmlResource()的逻辑中出现判重出错，报org.apache.ibatis.binding.BindingException异常，      // 即使xml文件中包含的内容和mapper接口中包含的语句不重复也会出错，包括加载mapper接口时自动加载的xml mapper也一样会出错。      if (&quot;package&quot;.equals(child.getName())) &#123;        //  &lt;package name=&quot;org.mybatis.internal.example.mapper&quot;/&gt;        String mapperPackage = child.getStringAttribute(&quot;name&quot;);        configuration.addMappers(mapperPackage);      &#125; else &#123;        String resource = child.getStringAttribute(&quot;resource&quot;);        String url = child.getStringAttribute(&quot;url&quot;);        String mapperClass = child.getStringAttribute(&quot;class&quot;);        if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;          //  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;          ErrorContext.instance().resource(resource);          try(InputStream inputStream = Resources.getResourceAsStream(resource)) &#123;            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());            // mapperParser.parse()方法就是XMLMapperBuilder对Mapper映射器文件进行解析            mapperParser.parse();          &#125;        &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;          //  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;          ErrorContext.instance().resource(url);          try(InputStream inputStream = Resources.getUrlAsStream(url))&#123;            // 解析映射配置文件            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());            mapperParser.parse();          &#125;        &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;          //  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;          // 反射加载对象          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);          configuration.addMapper(mapperInterface);        &#125; else &#123;          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>这段代码长一点，我们把它分一下类,从代码上我们可以看出，他按照<code>child.getName()</code>的不同分别进行了处理</p><p>一共四种情况，也就是mybatis.xml配置文件四种不同标签加载mapper的方法。虽然分为了四种情况但是他最终执行的代码是相同的，我们只看<code>package</code>包扫描的方式，因为这种方式用的比较多。</p><pre><code class="xml">/** * &lt;mappers&gt; *     &lt;package name=&quot;org.mybatis.internal.example.mapper&quot;/&gt; * &lt;/mappers&gt; */if (&quot;package&quot;.equals(child.getName())) &#123;  // 包名：org.mybatis.internal.example.mapper  String mapperPackage = child.getStringAttribute(&quot;name&quot;);  configuration.addMappers(mapperPackage);&#125;/** * &lt;mappers&gt; *     &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; * &lt;/mappers&gt; */if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;    ...&#125;/** * &lt;mappers&gt; *     &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; * &lt;/mappers&gt; */if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;    ...&#125;/** * &lt;mappers&gt; *     &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt; * &lt;/mappers&gt; */if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;    ...&#125;</code></pre><p>我们看一下包扫描这种方法到底干了什么？</p><p>点击这个方法 configuration.addMappers(“mapper接口的包名”)，我就康康不乱动！(●ˇ∀ˇ●)</p><p>点击config的addMappers方法发现又是老样子，他又交给了别人处理了</p><pre><code class="java">mapperRegistry.addMappers(packageName);</code></pre><p>config是调用了mapperRegistry的addMappers方法，好吧！我进入的深一点，我再跟进去。</p><pre><code class="java">  public void addMappers(String packageName, Class&lt;?&gt; superType) &#123;    // mybatis框架提供的搜索classpath下指定package以及子package中符合条件(注解或者继承于某个类/接口)的类，默认使用Thread.currentThread().getContextClassLoader()返回的加载器,和spring的工具类殊途同归。    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();    // 无条件的加载所有的类,因为调用方传递了Object.class作为父类,这也给以后的指定mapper接口预留了余地    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);    // 所有匹配的calss都被存储在ResolverUtil.matches字段中    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();    for (Class&lt;?&gt; mapperClass : mapperSet) &#123;      //调用addMapper方法进行具体的mapper类/接口解析      addMapper(mapperClass);    &#125;  &#125;</code></pre><p>当我进入这个方法的时候发现，哎,这里的代码多肯定是这里没错了。我们看看这里做了什么操作。</p><p>首先得到了一个包搜索工具 resolverUtil</p><p>通过这个工具拿到了这个包下所有的mapper接口的class对象mapperSet，是一个set集合，然后遍历集合，他又调用了 addMappers方法，这次传递的参数是每个mapper接口的class对象。没办法再进去看看</p><pre><code class="java"> public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;    // 对于mybatis mapper接口文件，必须是interface，不能是class，因为mybatis用的是jdk动态代理    if (type.isInterface()) &#123;      // 判重，确保只会加载一次不会被覆盖      if (hasMapper(type)) &#123;        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);      &#125;      boolean loadCompleted = false;      try &#123;        // 生成一个MapperProxyFactory，用于之后生成动态代理类        // 为mapper接口创建一个MapperProxyFactory代理工厂，将mapper接口与工厂建立关系，当使用这个mapper的代理类时再去生产一个代理类        knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));        // It&#39;s important that the type is added before the parser is run        // otherwise the binding may automatically be attempted by the        // mapper parser. If the type is already known, it won&#39;t try.        // MapperAnnotationBuilder进行具体的解析        //以下代码片段用于解析我们定义的XxxMapper接口里面使用的注解，这主要是处理不使用xml映射文件的情况        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);        parser.parse();        loadCompleted = true;      &#125; finally &#123;        if (!loadCompleted) &#123;          //剔除解析出现异常的接口          knownMappers.remove(type);        &#125;      &#125;    &#125;  &#125;</code></pre><p>这片代码写了啥，一堆的判断….. 嗯就一两句我们想看到的</p><pre><code class="java">knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);        parser.parse();</code></pre><p>第一个 让我们终于知道了，我们那些mapper接口到底去哪里了，原来在这个他为每个mapper接口创建了一一对应的MapperProxyFactory代理工厂，并将这些工厂存放到了 map对象中。</p><ul><li><p>key: mapperClass</p></li><li><p>value：MapperProxyFactory&lt;&gt;(mapperClass)</p></li></ul><p>第二个 用于解析我们定义的XxxMapper接口里面使用的注解，这主要是处理不使用xml映射文件的情况。这里不在深入，谁想看自己去看。</p><p>最后还执行了一句解析 <code>parser.parse()</code>，这个解析到底在解析什么，我们在~~~~点击去看一下。</p><p>这里东西有点多，看一下的我的源码片段，这里我都进行了注释。</p><pre><code class="java"> /**   * MapperBuilderAssistant初始化完成之后，就调用build.parse()进行具体的mapper接口文件加载与解析   */  public void parse() &#123;    String resource = type.toString();    //首先根据mapper接口的字符串表示判断是否已经加载,避免重复加载,正常情况下应该都没有加载    if (!configuration.isResourceLoaded(resource)) &#123;      //⭐⭐⭐⭐⭐ 加载Mapper.xml资源，这里面就是解析mapper.xml的方法      loadXmlResource();      configuration.addLoadedResource(resource);      // 命名空间 每个mapper文件自成一个namespace，通常自动匹配就是这么来的，约定俗成代替人工设置最简化常见的开发      assistant.setCurrentNamespace(type.getName());      parseCache();      parseCacheRef();      for (Method method : type.getMethods()) &#123;        if (!canHaveStatement(method)) &#123;          continue;        &#125;        if (getAnnotationWrapper(method, false, Select.class, SelectProvider.class).isPresent()            &amp;&amp; method.getAnnotation(ResultMap.class) == null) &#123;          parseResultMap(method);        &#125;        try &#123;          parseStatement(method);        &#125; catch (IncompleteElementException e) &#123;          configuration.addIncompleteMethod(new MethodResolver(this, method));        &#125;      &#125;    &#125;    parsePendingMethods();  &#125;</code></pre><p>loadXmlResource这个方法将mapper.xml进行了解析，具体怎么解析自己看。</p><pre><code class="java"> private void loadXmlResource() &#123;    // 判断资源是否已经加载过    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) &#123;      // 得到xml的相对路径 例如：com.xx.mapper.UserMapper.xml 注意这是指在resources 问价夹下的资源目录      // type值得是mapper接口文件的信息      // type.getName() = com.xx.mapper.UserMapper      // 他会解析成 com/xx/mapper/UserMapper.xml      String xmlResource = type.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.xml&quot;;      // 加载xml 的文件流      InputStream inputStream = type.getResourceAsStream(&quot;/&quot; + xmlResource);      if (inputStream == null) &#123;        try &#123;          // ClassLoader.getSystemClassLoader(); 通过类加载器加载          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);        &#125; catch (IOException e2) &#123;        &#125;      &#125;      if (inputStream != null) &#123;        // 调用XMLMapperBuilder 解析mapper.xml文件        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());        xmlParser.parse();      &#125;    &#125;  &#125;</code></pre><p>到现在我们知道了mybatis配置阶段到底执行了那东西。</p><p>接下来就是sql执行阶段了，欲知后事如何，且听下次讲解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mybatis源码分析-mybatis配置阶段的执行流程分析&quot;&gt;&lt;a href=&quot;#mybatis源码分析-mybatis配置阶段的执行流程分析&quot; class=&quot;headerlink&quot; title=&quot;mybatis源码分析-mybatis配置阶段的执行流程分析&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bigfish777.github.io/stars.github.io/2021/05/19/hello-world/"/>
    <id>https://bigfish777.github.io/stars.github.io/2021/05/19/hello-world/</id>
    <published>2021-05-19T08:02:58.892Z</published>
    <updated>2021-05-19T08:02:58.892Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
