<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一颗小土豆</title>
  
  <subtitle>一颗小土豆</subtitle>
  <link href="https://bigfish777.github.io/stars.github.io/atom.xml" rel="self"/>
  
  <link href="https://bigfish777.github.io/stars.github.io/"/>
  <updated>2021-05-20T02:31:33.931Z</updated>
  <id>https://bigfish777.github.io/stars.github.io/</id>
  
  <author>
    <name>一颗小土豆</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://bigfish777.github.io/stars.github.io/2021/05/20/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-mybatis%E9%85%8D%E7%BD%AE%E9%98%B6%E6%AE%B5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://bigfish777.github.io/stars.github.io/2021/05/20/mybatis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-mybatis%E9%85%8D%E7%BD%AE%E9%98%B6%E6%AE%B5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-05-20T02:31:33.931Z</published>
    <updated>2021-05-20T02:31:33.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis源码分析-mybatis配置阶段的执行流程分析"><a href="#mybatis源码分析-mybatis配置阶段的执行流程分析" class="headerlink" title="mybatis源码分析-mybatis配置阶段的执行流程分析"></a>mybatis源码分析-mybatis配置阶段的执行流程分析</h1><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><p>看源码到底怎么去看，我总结的是要有目的的去看源码。例如mybatis,我们在github拉下来源码后发现一堆代码，没头没尾无从下手。但是如果我们先写一个Demo,来分析这个demo的每一步到底干了什么，就好分析了。这也就是为啥学习一门新技术都需要先学习怎么使用。</p><h5 id="创建一个maven项目，引入mybatis的依赖"><a href="#创建一个maven项目，引入mybatis的依赖" class="headerlink" title="创建一个maven项目，引入mybatis的依赖"></a>创建一个maven项目，引入mybatis的依赖</h5><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h5 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h5><p><img src="C:\Users\24267\AppData\Roaming\Typora\typora-user-images\image-20210311132924065.png" alt="image-20210311132924065"></p><h5 id="创建一个实体类和对应的mapper接口"><a href="#创建一个实体类和对应的mapper接口" class="headerlink" title="创建一个实体类和对应的mapper接口"></a>创建一个实体类和对应的mapper接口</h5><pre><code class="java">/** 实体类 */public class File &#123;    private Integer id;    private Integer parentId;    private String name;    private Integer isFolder;    .... 省略get/set&#125;/** mapper接口 */public interface FileMapper &#123;    List&lt;File&gt; selectList();&#125;</code></pre><h5 id="mapper-xml"><a href="#mapper-xml" class="headerlink" title="mapper.xml"></a>mapper.xml</h5><p>一段很简单的sql语句，就是查询全部的file文件，我已经提前在数据库中插入了几条数据。数据库就不展示了，很简单就这几个字段。</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;org.mybatis.internal.example.mapper.FileMapper&quot;&gt;    &lt;select id=&quot;selectList&quot; resultType=&quot;org.mybatis.internal.example.pojo.File&quot;&gt;        select id,parent_id parentId, name, is_folder isFolder from file;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h5 id="在resource文件夹下创建一个myabtis-config-xml全局配置文件"><a href="#在resource文件夹下创建一个myabtis-config-xml全局配置文件" class="headerlink" title="在resource文件夹下创建一个myabtis-config.xml全局配置文件"></a>在resource文件夹下创建一个<code>myabtis-config.xml</code>全局配置文件</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;properties&gt;        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useUnicode=true&quot;/&gt;        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;        &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;    &lt;/properties&gt;    &lt;!--    配置别名 可以在mapper.xml中 使用简称就可以不用使用群全名了--&gt;    &lt;typeAliases&gt;&lt;!--        指定类设置别名--&gt;&lt;!--        &lt;typeAlias alias=&quot;user&quot; type=&quot;org.mybatis.internal.example.pojo.User&quot;/&gt;--&gt;&lt;!--        &lt;typeAlias alias=&quot;str&quot; type=&quot;java.lang.String&quot;/&gt;--&gt;&lt;!--        包扫面式的添加类别名，默认为类名首字母变为小写 如果个别的类需要指定别名可以使用 @Alias(&quot;us&quot;) 添加在实体类上--&gt;        &lt;package name=&quot;org.mybatis.internal.example.pojo&quot;/&gt;    &lt;/typeAliases&gt;&lt;!--    多数据源--&gt;    &lt;environments default=&quot;development2&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--            数据源模式 POOLED                dataSource的类型可以配置成其内置类型之一，如UNPOOLED、POOLED、JNDI。            　　如果将类型设置成UNPOOLED，mybaties会为每一个数据库操作创建一个新的连接，并关闭它。该方式适用于只有小规模数量并发用户的简单应用程序上。            　　如果将属性设置成POOLED，mybaties会创建一个数据库连接池，连接池的一个连接将会被用作数据库操作。一旦数据库操作完成，mybaties会将此连接返回给连接池。在开发或测试环境中经常用到此方式。            　　如果将类型设置成JNDI。mybaties会从在应用服务器向配置好的JNDI数据源DataSource获取数据库连接。在生产环境中优先考虑这种方式。--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;        &lt;environment id=&quot;development2&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;&lt;!--            数据源模式 POOLED                dataSource的类型可以配置成其内置类型之一，如UNPOOLED、POOLED、JNDI。            　　如果将类型设置成UNPOOLED，mybaties会为每一个数据库操作创建一个新的连接，并关闭它。该方式适用于只有小规模数量并发用户的简单应用程序上。            　　如果将属性设置成POOLED，mybaties会创建一个数据库连接池，连接池的一个连接将会被用作数据库操作。一旦数据库操作完成，mybaties会将此连接返回给连接池。在开发或测试环境中经常用到此方式。            　　如果将类型设置成JNDI。mybaties会从在应用服务器向配置好的JNDI数据源DataSource获取数据库连接。在生产环境中优先考虑这种方式。--&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&gt;        &lt;property name=&quot;SQL Server&quot; value=&quot;sqlserver&quot;/&gt;        &lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&gt;        &lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot; /&gt;    &lt;/databaseIdProvider&gt;&lt;!--    第一类是使用package自动搜索的模式，这样指定package下所有接口都会被注册为mapper，--&gt;&lt;!--    &lt;mappers&gt;--&gt;&lt;!--        &lt;mapper resource=&quot;mapper\UserMapper.xml&quot;/&gt;--&gt;&lt;!--        &lt;mapper resource=&quot;mapper\FileMapper.xml&quot;/&gt;--&gt;&lt;!--    &lt;/mappers&gt;--&gt;    &lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;    &lt;mappers&gt;        &lt;package name=&quot;org.mybatis.internal.example.mapper&quot;/&gt;    &lt;/mappers&gt;&lt;!--   另外一类是明确指定mapper，这又可以通过resource、url或者class进行细分。例如：--&gt;&lt;!--    &lt;mappers&gt;--&gt;&lt;!--        &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;--&gt;&lt;!--        &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;--&gt;&lt;!--        &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;--&gt;&lt;!--    &lt;/mappers&gt;--&gt;&lt;/configuration&gt;</code></pre><h5 id="现在创建main方法继续测试"><a href="#现在创建main方法继续测试" class="headerlink" title="现在创建main方法继续测试"></a>现在创建main方法继续测试</h5><pre><code class="java">public class MybatisHelloWorld &#123;    // 配置阶段        // 得到mybatis 配置类的文件路径        String resource = &quot;mybatis/Configuration.xml&quot;;        Reader reader = null;        SqlSession session = null;        try&#123;            Yaml yml = new Yaml();            LinkedHashMap map = yml.loadAs(MybatisHelloWorld.class.getClassLoader().getResourceAsStream(&quot;config.yml&quot;), LinkedHashMap.class);            System.out.println(map);            Map dataSourceMap = (Map)map.get(&quot;dataSource&quot;);            System.out.println(dataSourceMap.get(&quot;username&quot;));            // 通过Resources.getResourceAsReader 得到配置文件的字节流            reader = Resources.getResourceAsReader(resource);            // 这里的Properties 和配置文件Configuration.xml 里面的一致，使用Java配置可以实现动态的properties            Properties properties = new Properties();//            properties.setProperty(&quot;username&quot;, dataSourceMap.get(&quot;username&quot;) + &quot;&quot;);            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader,properties);            // 执行SQL阶段            // 得到一个session连接            session = sqlSessionFactory.openSession();            FileMapper fileMaper = session.getMapper(FileMapper.class);            List&lt;File&gt; fileList = fileMaper.selectList();            list.forEach(System.out::println);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;finally &#123;            session.commit();            session.close();        &#125;       &#125;</code></pre><h3 id="源码分析阶段"><a href="#源码分析阶段" class="headerlink" title="源码分析阶段"></a>源码分析阶段</h3><p>这段代码中核心的代码只有四句代码，这四句我把整个mybatis 从配置到执行sql语句得到想要的结果 分为两个阶段：</p><ul><li> <code>配置阶段</code> </li><li><code>执行阶段</code></li></ul><pre><code class="java">// 配置阶段// 创建sqlsession工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader,properties);// 得到一个session连接session = sqlSessionFactory.openSession();// 执行阶段// 获得mapper代理类FileMapper fileMaper = session.getMapper(FileMapper.class);// 执行查询方法List&lt;File&gt; fileList = fileMaper.selectList();</code></pre><p>我们一个一个的分析每个阶段的源码，首先是<code>配置阶段</code>,这个阶段我们首先要提出问题。</p><ul><li>SqlSessionFactory得到build需要将xml配置文件，他拿到这配置文件做了什么？怎么做的？</li></ul><pre><code>// 创建sqlsession工厂SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader,properties);// 得到一个session连接session = sqlSessionFactory.openSession();</code></pre><p>我们点击 build(reader,properties) 方法里面看一看他到底做了什么，点击去我们发现他最终调用了这个build方法,在这个方法里面创建了一个XMLConfigBuilder对象</p><pre><code class="java">public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123;    try &#123;//      解析配置文件的关键逻辑都委托给XMLConfigBuilder      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);      return build(parser.parse());    &#125; catch (Exception e) &#123;      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);    &#125; finally &#123;      ErrorContext.instance().reset();      try &#123;        reader.close();      &#125; catch (IOException e) &#123;        // Intentionally ignore. Prefer previous error.      &#125;    &#125;  &#125;</code></pre><p>解析配置文件的关键逻辑都委托给XMLConfigBuilder，我们进入这个类一探究竟。这个类中最重要的三个方法都在这里</p><pre><code class="java">  private XMLConfigBuilder(XPathParser parser, String environment, Properties props) &#123;    super(new Configuration());    ErrorContext.instance().resource(&quot;SQL Mapper Configuration&quot;);    this.configuration.setVariables(props);    this.parsed = false;    this.environment = environment;    this.parser = parser;  &#125;  /**   * 外部调用此方法对mybatis配置文件进行解析   * 第四步 真正Configuration构建逻辑就在XMLConfigBuilder.parse()里面   */  public Configuration parse() &#123;    if (parsed) &#123;      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);    &#125;    parsed = true;    //mybatis配置文件解析的主流程    //从根节点configuration    // 返回根节点 parser.evalNode(&quot;/configuration&quot;)    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));    return configuration;  &#125;  //此方法就是解析configuration节点下的子节点  //由此也可看出，我们在configuration下面能配置的节点为以下11个节点  private void parseConfiguration(XNode root) &#123;    try &#123;      // issue #117 read properties first      // 这里是按照官网的配置文件顺序进行解析的 https://mybatis.org/mybatis-3/zh/configuration.html      propertiesElement(root.evalNode(&quot;properties&quot;));      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));      loadCustomVfs(settings);      loadCustomLogImpl(settings);      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));      pluginElement(root.evalNode(&quot;plugins&quot;));      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));      settingsElement(settings);      // read it after objectFactory and objectWrapperFactory issue #631      environmentsElement(root.evalNode(&quot;environments&quot;));      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));      mapperElement(root.evalNode(&quot;mappers&quot;));    &#125; catch (Exception e) &#123;      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);    &#125;  &#125;</code></pre><p>我们发现在parseConfiguration（）方法中对xml配置文件进行了解析，此方法就是解析configuration节点下的子节点，解析的顺序是按照配置文件的配置顺序依次进行的解析。其中最重要得到<mappers>的解析，这里就是对mapper的解析处理，我们进去方法mapperElement看一看是怎么实现的。</p><pre><code class="java">/** *  加载mapper文件mapperElement * 　mapper文件是mybatis框架的核心之处，所有的用户sql语句都编写在mapper文件中，所以理解mapper文件对于所有的开发人员来说都是必备的要求 * @param parent * @throws Exception */private void mapperElement(XNode parent) throws Exception &#123;  if (parent != null) &#123;    for (XNode child : parent.getChildren()) &#123;      // 如果要同时使用package自动扫描和通过mapper明确指定要加载的mapper，一定要确保package自动扫描的范围不包含明确指定的mapper，      // 否则在通过package扫描的interface的时候，尝试加载对应xml文件的loadXmlResource()的逻辑中出现判重出错，报org.apache.ibatis.binding.BindingException异常，      // 即使xml文件中包含的内容和mapper接口中包含的语句不重复也会出错，包括加载mapper接口时自动加载的xml mapper也一样会出错。      if (&quot;package&quot;.equals(child.getName())) &#123;        //  &lt;package name=&quot;org.mybatis.internal.example.mapper&quot;/&gt;        String mapperPackage = child.getStringAttribute(&quot;name&quot;);        configuration.addMappers(mapperPackage);      &#125; else &#123;        String resource = child.getStringAttribute(&quot;resource&quot;);        String url = child.getStringAttribute(&quot;url&quot;);        String mapperClass = child.getStringAttribute(&quot;class&quot;);        if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;          //  &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt;          ErrorContext.instance().resource(resource);          try(InputStream inputStream = Resources.getResourceAsStream(resource)) &#123;            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());            // mapperParser.parse()方法就是XMLMapperBuilder对Mapper映射器文件进行解析            mapperParser.parse();          &#125;        &#125; else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;          //  &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt;          ErrorContext.instance().resource(url);          try(InputStream inputStream = Resources.getUrlAsStream(url))&#123;            // 解析映射配置文件            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());            mapperParser.parse();          &#125;        &#125; else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;          //  &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt;          // 反射加载对象          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);          configuration.addMapper(mapperInterface);        &#125; else &#123;          throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);        &#125;      &#125;    &#125;  &#125;&#125;</code></pre><p>这段代码长一点，我们把它分一下类,从代码上我们可以看出，他按照<code>child.getName()</code>的不同分别进行了处理</p><p>一共四种情况，也就是mybatis.xml配置文件四种不同标签加载mapper的方法。虽然分为了四种情况但是他最终执行的代码是相同的，我们只看<code>package</code>包扫描的方式，因为这种方式用的比较多。</p><pre><code>/** * &lt;mappers&gt; *     &lt;package name=&quot;org.mybatis.internal.example.mapper&quot;/&gt; * &lt;/mappers&gt; */if (&quot;package&quot;.equals(child.getName())) &#123;  // 包名：org.mybatis.internal.example.mapper  String mapperPackage = child.getStringAttribute(&quot;name&quot;);  configuration.addMappers(mapperPackage);&#125;/** * &lt;mappers&gt; *     &lt;mapper resource=&quot;org/mybatis/builder/AuthorMapper.xml&quot;/&gt; * &lt;/mappers&gt; */if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) &#123;    ...&#125;/** * &lt;mappers&gt; *     &lt;mapper class=&quot;org.mybatis.builder.AuthorMapper&quot;/&gt; * &lt;/mappers&gt; */if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) &#123;    ...&#125;/** * &lt;mappers&gt; *     &lt;mapper url=&quot;file:///var/mappers/PostMapper.xml&quot;/&gt; * &lt;/mappers&gt; */if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) &#123;    ...&#125;</code></pre><p>我们看一下包扫描这种方法到底干了什么？</p><p>点击这个方法 configuration.addMappers(“mapper接口的包名”)，我就康康不乱动！(●ˇ∀ˇ●)</p><p>点击config的addMappers方法发现又是老样子，他又交给了别人处理了</p><pre><code class="java">mapperRegistry.addMappers(packageName);</code></pre><p>config是调用了mapperRegistry的addMappers方法，好吧！我进入的深一点，我再跟进去。</p><pre><code>  public void addMappers(String packageName, Class&lt;?&gt; superType) &#123;    // mybatis框架提供的搜索classpath下指定package以及子package中符合条件(注解或者继承于某个类/接口)的类，默认使用Thread.currentThread().getContextClassLoader()返回的加载器,和spring的工具类殊途同归。    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = new ResolverUtil&lt;&gt;();    // 无条件的加载所有的类,因为调用方传递了Object.class作为父类,这也给以后的指定mapper接口预留了余地    resolverUtil.find(new ResolverUtil.IsA(superType), packageName);    // 所有匹配的calss都被存储在ResolverUtil.matches字段中    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();    for (Class&lt;?&gt; mapperClass : mapperSet) &#123;      //调用addMapper方法进行具体的mapper类/接口解析      addMapper(mapperClass);    &#125;  &#125;</code></pre><p>当我进入这个方法的时候发现，哎,这里的代码多肯定是这里没错了。我们看看这里做了什么操作。</p><p>首先得到了一个包搜索工具 resolverUtil</p><p>通过这个工具拿到了这个包下所有的mapper接口的class对象mapperSet，是一个set集合，然后遍历集合，他又调用了 addMappers方法，这次传递的参数是每个mapper接口的class对象。没办法再进去看看</p><pre><code class="java"> public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;    // 对于mybatis mapper接口文件，必须是interface，不能是class，因为mybatis用的是jdk动态代理    if (type.isInterface()) &#123;      // 判重，确保只会加载一次不会被覆盖      if (hasMapper(type)) &#123;        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);      &#125;      boolean loadCompleted = false;      try &#123;        // 生成一个MapperProxyFactory，用于之后生成动态代理类        // 为mapper接口创建一个MapperProxyFactory代理工厂，将mapper接口与工厂建立关系，当使用这个mapper的代理类时再去生产一个代理类        knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));        // It&#39;s important that the type is added before the parser is run        // otherwise the binding may automatically be attempted by the        // mapper parser. If the type is already known, it won&#39;t try.        // MapperAnnotationBuilder进行具体的解析        //以下代码片段用于解析我们定义的XxxMapper接口里面使用的注解，这主要是处理不使用xml映射文件的情况        MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);        parser.parse();        loadCompleted = true;      &#125; finally &#123;        if (!loadCompleted) &#123;          //剔除解析出现异常的接口          knownMappers.remove(type);        &#125;      &#125;    &#125;  &#125;</code></pre><p>这片代码写了啥，一堆的判断….. 嗯就一两句我们想看到的</p><pre><code class="java">knownMappers.put(type, new MapperProxyFactory&lt;&gt;(type));MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);        parser.parse();</code></pre><p>第一个 让我们终于知道了，我们那些mapper接口到底去哪里了，原来在这个他为每个mapper接口创建了一一对应的MapperProxyFactory代理工厂，并将这些工厂存放到了 map对象中。</p><ul><li><p>key: mapperClass</p></li><li><p>value：MapperProxyFactory&lt;&gt;(mapperClass)</p></li></ul><p>第二个 用于解析我们定义的XxxMapper接口里面使用的注解，这主要是处理不使用xml映射文件的情况。这里不在深入，谁想看自己去看。</p><p>最后还执行了一句解析 <code>parser.parse()</code>，这个解析到底在解析什么，我们在~~~~点击去看一下。</p><p>这里东西有点多，看一下的我的源码片段，这里我都进行了注释。</p><pre><code class="java"> /**   * MapperBuilderAssistant初始化完成之后，就调用build.parse()进行具体的mapper接口文件加载与解析   */  public void parse() &#123;    String resource = type.toString();    //首先根据mapper接口的字符串表示判断是否已经加载,避免重复加载,正常情况下应该都没有加载    if (!configuration.isResourceLoaded(resource)) &#123;      //⭐⭐⭐⭐⭐ 加载Mapper.xml资源，这里面就是解析mapper.xml的方法      loadXmlResource();      configuration.addLoadedResource(resource);      // 命名空间 每个mapper文件自成一个namespace，通常自动匹配就是这么来的，约定俗成代替人工设置最简化常见的开发      assistant.setCurrentNamespace(type.getName());      parseCache();      parseCacheRef();      for (Method method : type.getMethods()) &#123;        if (!canHaveStatement(method)) &#123;          continue;        &#125;        if (getAnnotationWrapper(method, false, Select.class, SelectProvider.class).isPresent()            &amp;&amp; method.getAnnotation(ResultMap.class) == null) &#123;          parseResultMap(method);        &#125;        try &#123;          parseStatement(method);        &#125; catch (IncompleteElementException e) &#123;          configuration.addIncompleteMethod(new MethodResolver(this, method));        &#125;      &#125;    &#125;    parsePendingMethods();  &#125;</code></pre><p>loadXmlResource这个方法将mapper.xml进行了解析，具体怎么解析自己看。</p><pre><code class="java"> private void loadXmlResource() &#123;    // 判断资源是否已经加载过    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) &#123;      // 得到xml的相对路径 例如：com.xx.mapper.UserMapper.xml 注意这是指在resources 问价夹下的资源目录      // type值得是mapper接口文件的信息      // type.getName() = com.xx.mapper.UserMapper      // 他会解析成 com/xx/mapper/UserMapper.xml      String xmlResource = type.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;.xml&quot;;      // 加载xml 的文件流      InputStream inputStream = type.getResourceAsStream(&quot;/&quot; + xmlResource);      if (inputStream == null) &#123;        try &#123;          // ClassLoader.getSystemClassLoader(); 通过类加载器加载          inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);        &#125; catch (IOException e2) &#123;        &#125;      &#125;      if (inputStream != null) &#123;        // 调用XMLMapperBuilder 解析mapper.xml文件        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());        xmlParser.parse();      &#125;    &#125;  &#125;</code></pre><p>到现在我们知道了mybatis配置阶段到底执行了那东西。</p><p>接下来就是sql执行阶段了，欲知后事如何，且听下次讲解</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mybatis源码分析-mybatis配置阶段的执行流程分析&quot;&gt;&lt;a href=&quot;#mybatis源码分析-mybatis配置阶段的执行流程分析&quot; class=&quot;headerlink&quot; title=&quot;mybatis源码分析-mybatis配置阶段的执行流程分析&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://bigfish777.github.io/stars.github.io/2021/05/19/hello-world/"/>
    <id>https://bigfish777.github.io/stars.github.io/2021/05/19/hello-world/</id>
    <published>2021-05-19T08:02:58.892Z</published>
    <updated>2021-05-19T08:02:58.892Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
